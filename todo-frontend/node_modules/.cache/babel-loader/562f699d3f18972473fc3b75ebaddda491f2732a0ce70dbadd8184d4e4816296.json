{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { todoApi } from '../api/todoApi';\nconst initialState = {\n  todos: [],\n  status: 'idle',\n  error: null\n};\nexport const fetchTodos = createAsyncThunk('todos/fetchTodos', async () => {\n  return await todoApi.getAllTodos();\n});\nexport const addNewTodo = createAsyncThunk('todos/addNewTodo', async todoData => {\n  const response = await todoApi.addTodo(todoData);\n  // 为了让Redux能够立即更新状态，我们需要返回完整的Todo对象\n  // 因为API只返回id和消息，我们需要构造一个完整的Todo对象\n  return {\n    id: response.id,\n    task: todoData.task,\n    status: todoData.status\n  };\n});\nexport const updateExistingTodo = createAsyncThunk('todos/updateExistingTodo', async ({\n  id,\n  todoData\n}) => {\n  await todoApi.updateTodo(id, todoData);\n  // 返回更新后的数据以便Redux更新状态\n  return {\n    id,\n    ...todoData\n  };\n});\nexport const deleteTodoItem = createAsyncThunk('todos/deleteTodoItem', async id => {\n  await todoApi.deleteTodo(id);\n  return id;\n});\nconst todoSlice = createSlice({\n  name: 'todos',\n  initialState,\n  reducers: {},\n  extraReducers: builder => {\n    builder\n    // 获取所有TODO\n    .addCase(fetchTodos.pending, state => {\n      state.status = 'loading';\n    }).addCase(fetchTodos.fulfilled, (state, action) => {\n      state.status = 'succeeded';\n      state.todos = action.payload;\n    }).addCase(fetchTodos.rejected, (state, action) => {\n      state.status = 'failed';\n      state.error = action.error.message || 'Failed to fetch TODO list';\n    })\n\n    // 添加TODO\n    .addCase(addNewTodo.fulfilled, (state, action) => {\n      state.todos.push(action.payload);\n    })\n\n    // 更新TODO\n    .addCase(updateExistingTodo.fulfilled, (state, action) => {\n      const {\n        id,\n        ...changes\n      } = action.payload;\n      const existingTodo = state.todos.find(todo => todo.id === id);\n      if (existingTodo) {\n        Object.assign(existingTodo, changes);\n      }\n    })\n\n    // 删除TODO\n    .addCase(deleteTodoItem.fulfilled, (state, action) => {\n      const id = action.payload;\n      state.todos = state.todos.filter(todo => todo.id !== id);\n    });\n  }\n});\nexport default todoSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","todoApi","initialState","todos","status","error","fetchTodos","getAllTodos","addNewTodo","todoData","response","addTodo","id","task","updateExistingTodo","updateTodo","deleteTodoItem","deleteTodo","todoSlice","name","reducers","extraReducers","builder","addCase","pending","state","fulfilled","action","payload","rejected","message","push","changes","existingTodo","find","todo","Object","assign","filter","reducer"],"sources":["D:/shawn_workspace/CSSI project/fullstack repo3/todo-frontend/src/store/todoSlice.ts"],"sourcesContent":["import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';\r\nimport { Todo, TodoFormData } from '../types/types';\r\nimport { todoApi } from '../api/todoApi';\r\n\r\ninterface TodoState {\r\n  todos: Todo[];\r\n  status: 'idle' | 'loading' | 'succeeded' | 'failed';\r\n  error: string | null;\r\n}\r\n\r\nconst initialState: TodoState = {\r\n  todos: [],\r\n  status: 'idle',\r\n  error: null,\r\n};\r\n\r\nexport const fetchTodos = createAsyncThunk(\r\n  'todos/fetchTodos',\r\n  async () => {\r\n    return await todoApi.getAllTodos();\r\n  }\r\n);\r\n\r\nexport const addNewTodo = createAsyncThunk(\r\n  'todos/addNewTodo',\r\n  async (todoData: TodoFormData) => {\r\n    const response = await todoApi.addTodo(todoData);\r\n    // 为了让Redux能够立即更新状态，我们需要返回完整的Todo对象\r\n    // 因为API只返回id和消息，我们需要构造一个完整的Todo对象\r\n    return {\r\n      id: response.id!,\r\n      task: todoData.task,\r\n      status: todoData.status,\r\n    } as Todo;\r\n  }\r\n);\r\n\r\nexport const updateExistingTodo = createAsyncThunk(\r\n  'todos/updateExistingTodo',\r\n  async ({ id, todoData }: { id: string; todoData: Partial<TodoFormData> }) => {\r\n    await todoApi.updateTodo(id, todoData);\r\n    // 返回更新后的数据以便Redux更新状态\r\n    return { id, ...todoData };\r\n  }\r\n);\r\n\r\nexport const deleteTodoItem = createAsyncThunk(\r\n  'todos/deleteTodoItem',\r\n  async (id: string) => {\r\n    await todoApi.deleteTodo(id);\r\n    return id;\r\n  }\r\n);\r\n\r\nconst todoSlice = createSlice({\r\n  name: 'todos',\r\n  initialState,\r\n  reducers: {},\r\n  extraReducers: (builder) => {\r\n    builder\r\n      // 获取所有TODO\r\n      .addCase(fetchTodos.pending, (state) => {\r\n        state.status = 'loading';\r\n      })\r\n      .addCase(fetchTodos.fulfilled, (state, action: PayloadAction<Todo[]>) => {\r\n        state.status = 'succeeded';\r\n        state.todos = action.payload;\r\n      })\r\n      .addCase(fetchTodos.rejected, (state, action) => {\r\n        state.status = 'failed';\r\n        state.error = action.error.message || 'Failed to fetch TODO list';\r\n      })\r\n      \r\n      // 添加TODO\r\n      .addCase(addNewTodo.fulfilled, (state, action: PayloadAction<Todo>) => {\r\n        state.todos.push(action.payload);\r\n      })\r\n      \r\n      // 更新TODO\r\n      .addCase(updateExistingTodo.fulfilled, (state, action) => {\r\n        const { id, ...changes } = action.payload;\r\n        const existingTodo = state.todos.find(todo => todo.id === id);\r\n        if (existingTodo) {\r\n          Object.assign(existingTodo, changes);\r\n        }\r\n      })\r\n      \r\n      // 删除TODO\r\n      .addCase(deleteTodoItem.fulfilled, (state, action: PayloadAction<string>) => {\r\n        const id = action.payload;\r\n        state.todos = state.todos.filter(todo => todo.id !== id);\r\n      });\r\n  },\r\n});\r\n\r\nexport default todoSlice.reducer;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}